#进程、轻量级进程和线程
#进程描述符
##进程状态
##标识一个进程
###进程描述符处理
###标识当前进程
###双向链表
###进程链表
###TASK_RUNNING状态的进程链表

##进程间的关系
###pidhash表及链表

##如何组织进程
###等待队列
###等待队列的操作


##进程资源限制

#进程切换
##硬件上下文
##任务状态段
###thread字段
##执行进程切换
###switch_to宏
###__switch_to()函数

##保存和加载FPU,MMX及XMM寄存器
###保存FPU寄存器
###装载FPU寄存器
###在内核态使用FPU,MMX和SSE/SSE2单元


#创建进程
	传统操作：子进程复制父进程所拥有的的资源
	引入问题：传统方法效率低。-多数情况下子进程不适用父进程的资源，会调用execve(),清除父进程拷贝的地址空间。
	现代解决办法(3种机制)：1.写时复制；
						   2.轻量级进程，允许父子进程共享多数数据结构。
						   3.vofrk()系统调用创建的进程共享父进程地址空间。为防止父进程重写子进程数据，阻塞父进程直到
							子进程退出或执行一个新的程序。
##clone(),fork及vfork()系统调用
	clone()函数-作用：创建轻量级进程,实际是c语言库的封装函数
				输入：fn-新进程执行的函数。返回时，子进程终止。
					  arg-传递给fn()函数的数据
					  flags-低字节指定发送到父进程信号代码(一般是SIGCHLD)，剩余3字节给一clone标志组用于编码。
					  child_stack:用户态堆栈指针赋给子进程的esp。调用进程总是分配新的堆栈给子进程。
					  tls-线性局部存储段地址。为新轻量级进程定义，CLONE_SETTLS set才有意义。
					  ptid-父进程用户态变量地址。CLONE_PARENT_SETTID set才有意义。
					  ctid-新轻量级进程用户态变量地址。CLONE_CHILD_SETTID set才有意义。
	clone标志：
		CLONE_VM
		CLONE_FS
		CLONE_FILES
		CLONE_SIGHAND
		CLONE_PTRACE
		CLONE_VFORK
		CLONE_PARENT
		CLONE_THREAD
		CLONE_NEWNS
		CLONE_SYSVSEM
		CLONE_SETTLS
		CLONE_PARENT_SETTID
		CLONE_CHILD_CLEARTID
		CLONE_DETACHED
		CLONE_UNTRACED
		CLONE_CHILD_SETTID
		CLONE_STOPPED
	传统fork()函数同过clone实现：实现方法-需要把flags参数指定为SIGCHLD,且clone标志CLONE_VM和CLONE_VFORK。
								 完成后，父子进程暂时共享用户态堆栈。通过写时共享技术分离。
	vfork()函数同过clone实现：实现方法-需要把flags参数指定为SIGCHLD,且clone标志清0。
								 完成后，父子进程暂时共享用户态堆栈。通过写时共享技术分离。
###do_fork()函数
	处理clone(),fork及vfork()系统调用。
	流程：1.分配 新PID-通过 pidmap_array.
		  2.检查是否有其他程序跟踪父进程-通过current->ptrace
										 处理：通过独立程序查看是否也想跟踪子进程，如果子进程不是内核线程，
												则 SET CLONE_PTRACE
		  3.关键步骤 copy_process()-复制进程描述符，如果资源是可用的，返回描述符地址。
		  4.检查CLONE_STOPPED标志是否被设置。N 怎跳转到 step5。
		  5.检查。IF NOT SET CLONE_STOPPED,THEN wake_up_new_task(),操作如下：
			-调整父子进程调度参数
			-根据是否在同一CPU上或父子享受同一页表，决定子进程怎样插入队列
		  6.检查if CLONE_STOPPED THEN 子进程 TASK_STOPPED.
		  7.检查如果父进程被跟踪，操作子进程PID.
		  8.检查IF SET CLONE_VFORK, THEN 把父进程插入等待队列，挂起直到子进程释放。
		  9.结束，返回子进程ID.
			
								   
###copy_porcess()函数
	作用：创建 进程描述符 及子进程需要的其他数据结构。
	输入：同do_fork，外加子进程PID.
	步骤：1.检查 clone_flags 标志一致性。
			返回错误的情形：1) SET CLONE_NEWNS && SET CLONE_FS
							2) SET CLONE_THREAD && CLONE_SIGHAND =0 同一线程组轻量级进程必须共享信号
							3) SET CLONE_SIGHAND && CLONE_VM =0 共享信号处理程序的轻量级进程必须共享内存描述符
		  2.检查 附加安全性-通过 security_task_create() and security_task_alloc()。钩子函数
		  3.获取进程描述符-通过 dup_task_struct(),过程如下：
			1) 如需要 保存 FPU\MMX\SSE/SSE2 寄存器 ---> 父进程thread_info
			2) 为新进程获取 进程描述符。-通过alloc_task_struct()。描述符地址--->tsk。
			3) 获取内核栈和thread_info的空闲内存图-通过alloc_thread_info ,内存区地址--->ti。
			4) 填充进程描述符内容-通过复制父进程描述符，然后 tsk->thread_info=ti。
			5) 填充 thread_info -将父进程的复制到ti指向地址。
			6) 设置新进程状态 - tsk-usage =2,表示进程描述符正在被使用且相应进程处于活动状态。
			7) 返回描述符指针tsk.
		  4.检查 current->signal->rlim[RLIMIT_NPROC].rlim_cur
		  5.递增计数器 tsk-user->__count tsk_user->processes.
		  6.检查进程数量是否超过最大值 max_threads 。总原则是内核栈占用空间不能超过物理地址 1/8，
									但可通过 /proc/sys/kernel/threads-max 修改
		  7.递增使用计数器-如果实现新进程的执行域和可执行函数 in 内核模块。
		  8.设置进程状态：1.tsk->lock_depth =-1.大内核计数。
						  2.tsk->did_exec=0,是execve()调用次数。
						  3.更新flags。
		  9.设置新PID.
		  10.检查 CLONE_PARENT_SETTID 。
		  11.初始化list_head,自旋锁、挂起信号、定时器、时间统计表。
		  12.复制父进程数据到新进程数据结构中。除非clone_flags
			copy_semundo(),copy_files(),copy_fs(),copy_sighand(),copy_signal(),copy_mm(),copy_namespace().
		  13.初始化子进程内核栈。-调用copy_thread(),使用clone时CPU寄存器的值。
									例外：eax《-0，thread.esp=子进程内核栈基地址。
		  14.检查 CLONE_CHILD_CLEARTID或CLONE_CHILD_SETTID标志。
		  15.清除 TIF_SYSCALL_TRACE 标志，使 系统调用结束消息不会发给调试进程。
		  16.初始化tsk->exit_signal :根据CLONE_FLAGS低位。
		  17.初始化新进程调度程序数据结构-sched_fork():设置 TASK_RUNNING;
														preempt_count = 1,禁止抢占
														该函数在父子进程间共享父进程时间片
		  18.设置新进程thread_info的cpu号-smp_processor_id。
		  19.初始化亲子关系字段。
		  20.检查 CLONE_PTRACE 字段。
		  21.新进程描述符插入链表-SET_LINK
		  22.检查子进程是否必须跟踪情况。如果是，插入到跟踪列表。
		  23.将PID插入 pidhash[PIDTYPE_PID]散列表。
		  24.检查子进程是否是领头进程（CLONE_THREAD ==0）:
				tsk->tgid = tsk->pid
				tsk->group_leader =tsk
				插入子进程到3个不同类型散列表：attach_pid(),PIDTYPE_TGID,PIDTYPE_PGID,PIDTYPE_SID。
			elseif CLONE_THREAD ==1   子进程是父进程线程组
			    tsk->tgid = tsk->current->pid
				tsk->group_leader =current->group_leader
				插子进程到散列表：attach_pid(),PIDTYPE_TGID。
		  26.递增计数器。
		  27.返回子进程描述符指针tsk。
							
##内核线程
###创建一个内核线程
###进程0
###进程1
###其他内核线程


#撤销进程
##进程终止
###do_group_exit()函数
###do_exit()函数

##进程删除